package allocation

import allocation.*
import allocation.facts.*
import allocation.actions.*
import allocation.newagents.*
import uk.ac.imperial.presage2.core.IntegerTime
import uk.ac.imperial.presage2.core.util.random.Random
import java.util.HashMap
import java.util.List
import java.util.Set

global org.apache.log4j.Logger logger

declare TaskExecuted
	institution : Institution
	task : String
	round : int
end

declare Monitored
	agent : String
	round : int
end

declare Declared
	institution : int
	ballot : String
	round : int
	result : int
end

declare Deducted
	monitor : Monitored
end

declare Sanctioned
	agent: String //name
	round: int
	level: int
end

declare Appealed
	agent: String //name
	round: int
end

declare ExcludeHead
	institution : int
	round : int
end
	

//sets IntegerTime and round number to be the same
rule "Increment round" 
	ruleflow-group 'init'
	when
		$t : IntegerTime()
		$i : Institution( round < $t.intValue() )
	then
		modify($i) {
			incrementRound()
		}
end

rule "Count members"
	ruleflow-group 'init'
	when
		$i : Institution( $iid : id, $count : memberCount )
		List( size != $count, $members : size ) from collect( Member( institutionId == $iid ) )
	then
		modify($i) {
			setMemberCount( $members );
		}
end

rule "Count active members"
	ruleflow-group 'init'
	when
		$i : Institution( $iid : id, $count : activeMemberCount )
		List( size != $count, $members : size ) from collect( Member( institutionId == $iid, active == true ) )
	then
		modify($i) {
			setActiveMemberCount( $members );
		}
end

rule "Disable votes" //head renews it every timestep in CFV
	ruleflow-group 'init'
	when 
		$inst : Institution( voteHead || voteRaMethod )
		//only for institutions with Pr3=true?? :
		//$inst : Institution(( voteHead || voteRaMethod ), principle3 == true )
	then
		modify($inst) {
			setVoteHead( false ),
			setVoteRaMethod( false )
		}
end

rule "Call for votes"
	ruleflow-group 'cfv'
	no-loop
	when
		IntegerTime()//what's that for??
		$head : Head( $iid : institutionId )
		$i : Institution( id == $iid, principle3 == true)
	then
		CallForVote cfv = $head.callForVotes( $i );
		if(cfv != null) {
			modify( $i ) {
				setVoteHead( cfv.isHead() ),	
				setVoteRaMethod( cfv.isRaMethod() )
			}
			logger.info(cfv);
		}
end


rule "Vote for RA method"
	salience 1000
	ruleflow-group 'vote'
	when
		$member : Member( $iid : institutionId, $pid : pool )
		$i : Institution( id == $iid, voteRaMethod, $r : round , principle3 == true)
		$pool : CommonPool( id == $pid )
	then
		Vote v = $member.vote( $i, $pool, "raMethod" );
		if(v != null) {
			v.setVoter( $member.getName() );
			v.setRound( $r );
			insert(v);
			logger.info(v);
		}
end

rule "Count votes"
	ruleflow-group 'vote'
	when
		Institution( $iid : id, $round : round, principle3 == true )
		Vote( $ag : voter, round == $round, $b : ballot )
		Member( name == $ag, institutionId == $iid )
		not VoteCount( institution == $iid, ballot == $b, round == $round )
		$votes : List( size > 0 ) from accumulate( 
			$v : Vote( $voter : voter, round == $round, ballot == $b ) and 
			Member( name == $voter, institutionId == $iid ) , collectList($v) )
	then
		HashMap<Integer, Integer> tally = new HashMap<Integer, Integer>();
		for( Object o : $votes ) {
			Vote v = (Vote) o; // vote->(ballot,value)
			if(tally.containsKey(v.getValue())) {
				tally.put(v.getValue(), tally.get(v.getValue()) + 1);
			} else {
				tally.put(v.getValue(), 1);
			}
		}
		insert( new VoteCount( $iid, $b, $round, tally ) );
end


rule "Echo Votes Counted"//why not in 'count votes' after insert??
	ruleflow-group 'vote'
	when
		$vc : VoteCount()
	then
		logger.info( $vc );
end

rule "Declare winner and update Ra method" //if votes equal, nothing happens;
	ruleflow-group 'vote'
	when
		$vc : VoteCount( ballot == "raMethod", $iid : institution )
		$i : Institution( id == $iid, round == $vc.round , principle3 == true )
	then
		Integer forQueue = $vc.result.get(RaMethod.QUEUE.ordinal());
		Integer forRation = $vc.result.get(RaMethod.RATION.ordinal());
		if(forQueue == null) forQueue = 0;
		if(forRation == null) forRation = 0;

		if(forQueue > forRation) {//in C++ queue >= ration; here nothing changes if queue = ration
			$i.setAllocationMethod( RaMethod.QUEUE );
		} else if(forRation > forQueue) {
			$i.setAllocationMethod( RaMethod.RATION );
		}
		insert(new Declared( $iid, $vc.ballot, $vc.round, $i.getAllocationMethod().ordinal() ));
		logger.info("Allocation method for institution "+ $iid +" set to "+ $i.getAllocationMethod()); 
end

rule "Echo Declared" //is that not there yet, after insert in 'declare winner...'??
	ruleflow-group 'vote'
	when
		$d : Declared()
	then
		logger.info( $d );
end

rule "External assignment of RaMethod"//NEW!!
	ruleflow-group 'vote'
	when
		$i : Institution( $iid : id , $r : round, round % samplingrate == 0, $pool : pool, principle3 == false)
		$hd : Head( institutionId == $iid )
	then
		if ($pool.getResourceLevel() < 1.5*$i.getInitialAgents()*$hd.getStandardRequest()){
			$i.setAllocationMethod( RaMethod.RATION );
		}
		else
			$i.setAllocationMethod( RaMethod.QUEUE );
		insert(new Declared( $iid, "raMethod", $r, $i.getAllocationMethod().ordinal() ));//works immediately??
		logger.info("Allocation method for institution "+ $iid +" externally set to "+ $i.getAllocationMethod());
end

rule "Reset demand-queue if necessary" //when switch from QUEUE to RATION
	ruleflow-group 'vote'
	when 
		$i : Institution( $iid : id , $r : round )
		Declared(institution == $iid, ballot == "raMethod",  result == RaMethod.RATION.ordinal(), round == $r )
		Declared(institution == $iid, ballot == "raMethod", result == RaMethod.QUEUE.ordinal(), $rb : round, $rb < $r)
		not Declared(institution == $iid, ballot == "raMethod", result == RaMethod.RATION.ordinal(), round > $rb)
	then
		$i.demandQueue.clear();
end
		

rule "Member Demands"
	salience 1000
	ruleflow-group 'demand'
	when
		$inst : Institution( $iid : id, $round : round, $pool : pool, principle2 == true )
		$member : Member( institutionId == $iid )
		//no agent allowed to demand twice:
		not Demand( agent == $member.name, round < $round, this memberOf $inst.demandQueue )
	then
		insert( new Demand( $round, $pool.getId(), $member.getName(), $member.demand( $inst, $pool ) ) );
end

rule "Agent monitoring list" 
	//independent of principle: collect all (non-)members
	//must be known before allocation, only monitor 'active' -> head.monitor
	//head.monitor writes those on list (=monitored string) who should be monitored
	ruleflow-group "allocate" 
	salience 1000
	when
		$i : Institution( $iid : id, $round : round, $pool : pool )
		not TaskExecuted( $i, "monitor", $round ;)
		$head : Head( institutionId == $iid, pool == $pool.id )
		$members : Set( ) from collect( Member( institutionId == $iid) )
		$nonMembers : Set( ) from collect( NonMember( pool == $pool.id) )//NonMember was Agent before!!
	then
		Set<String> monitored = $head.monitor( $i, $pool, $members, $nonMembers );
		logger.info("Monitoring list: "+ monitored);
		for( String agent : monitored ) {
			insert( new Monitored( agent, $round ) );
		}
		insert( new TaskExecuted( $i, "monitor", $round ) );
end

rule "Perform resource allocation"
	ruleflow-group 'allocate'
	when
		// get an institution in allocate phase
		$inst : Institution( $iid : id, $round : round, $pool : pool, principle2 == true )
		// get the head
		$hd : Head( institutionId == $iid )
		// get demands for this pool
		$demands : List( ) from collect( Demand( pool == $pool.id, round == $round ) )
	then
		logger.info( $demands );
		Set<Allocation> allocations = $hd.allocate($inst, $pool, $demands);
		logger.info(allocations);
		for(Allocation a : allocations) {
			insert(a);
		}
end

rule "Member appropriation - no allocation"
	salience 1000
	ruleflow-group "appropriate"
	no-loop
	when
		$t : IntegerTime( )
		$member : Member( $iid : institutionId, $pid : pool )
		$i : Institution( id == $iid, $round : round )
		$pool : CommonPool( id == $pid )
		not Appropriated( round == $t.intValue(), agent == $member.getName() )
		not Allocation( round == $round, agent == $member.getName() )
	then
		double appropriatedAmount = $member.appropriate( $i, $pool, null );
		Appropriated app = new Appropriated( $member.getName(), $t.intValue(), appropriatedAmount, $pool );
		insert( app );
		modify($pool) {
			setResourceLevel( $pool.getResourceLevel() - appropriatedAmount )
		}
		logger.info(app);
		logger.info($pool);
end

rule "Member appropriation - allocated"
	salience 1000
	ruleflow-group "appropriate"
	no-loop
	when
		$member : Member( $iid : institutionId, $pid : pool )
		$i : Institution( id == $iid, $round : round )
		$pool : CommonPool( id == $pid )
		not Appropriated( round == $round, agent == $member.getName() )
		$all : Allocation( round == $round, agent == $member.getName() )
	then
		double appropriatedAmount = $member.appropriate( $i, $pool, $all );
		Appropriated app = new Appropriated( $member.getName(), $round, appropriatedAmount, $pool );
		insert( app );
		modify($pool) {
			setResourceLevel( $pool.getResourceLevel() - appropriatedAmount )
		}
		logger.info(app);
		//logger.info($pool);
end

// rule "NonMember appropriation" in environment.drl

rule "Deduct member monitoring cost" // happens after appropriation
	ruleflow-group "appropriate"
	when
		$i : Institution( $iid : id, $round : round )
		$m : Monitored( $name : agent, round == $round )
		not Deducted( $m ;)
		Member( name == $name, institutionId == $iid, $pid : pool )
		$pool : CommonPool( id == $pid )
	then
		modify( $pool ) {
			setResourceLevel( $pool.getResourceLevel() - $i.getMonitoringCost() ) 
		}
		insert( new Deducted( $m ) );
end

rule "Deduct nonMember monitoring cost" // happens after appropriation
	ruleflow-group "appropriate"
	when
		$pool : CommonPool( $pid : id )
		$i : Institution( $round : round, pool == $pool )
		$m : Monitored( $name : agent, round == $round )
		not Deducted( $m ;)// why ;??
		NonMember( name == $name, pool == $pid )
	then
		modify( $pool ) {
			setResourceLevel( $pool.getResourceLevel() - $i.getOutMonitoringCost() ) 
		}
		insert( new Deducted( $m ) );
end

rule "Sanctioning monitored members (first time or no graduated sanctions)" //not very important that it's the monitor/head
	ruleflow-group "report"
	no-loop 
	when
		$pool : CommonPool($pid : id )
		Institution($round : round, pool == $pool, $iid : id) //principle 4, graduation later.
		Monitored( $name : agent, round == $round )
		not Sanctioned( agent == $name, round == $round )
		$member: Member( name == $name, institutionId == $iid, pool == $pid )
		(	(Allocation(agent == $name, round == $round, $alloc : quantity) and //agent had been allocated
			Appropriated(agent == $name, round == $round, $approp : quantity, pool == $pool, $approp > $alloc))
		or
			(not Allocation(agent == $name, round == $round) and //agent had not been allocated
			Appropriated(agent == $name, round == $round, $approp : quantity, pool == $pool, $approp > 0))	)
		not Sanctioned(agent == $name)
	then 
		Sanctioned san = new Sanctioned($name, $round, 1);
		insert( san );
		modify ( $member ){
			setActive(false)
		}
		logger.info(san);
end

rule "Sanctioning monitored members (repeatedly)"
	ruleflow-group "report"
	no-loop 
	when
		$pool : CommonPool($pid : id )
		Institution($round : round, pool == $pool, $iid : id, principle5 == true)
		Monitored( $name : agent, round == $round )
		not Sanctioned( agent == $name, round == $round )
		$member: Member( name == $name, institutionId == $iid, pool == $pid )
		(	(Allocation(agent == $name, round == $round, $alloc : quantity) and //agent had been allocated
			Appropriated(agent == $name, round == $round, $approp : quantity, pool == $pool, $approp > $alloc))
		or
			(not Allocation(agent == $name, round == $round) and //agent had not been allocated
			Appropriated(agent == $name, round == $round, $approp : quantity, pool == $pool, $approp > 0))	)
		Sanctioned(agent == $name, $level : level) //highest level of sanctioning
		not Sanctioned(agent == $name, $l : level, $l > $level)
		
	then 
		Sanctioned san = new Sanctioned($name, $round, $level+1);
		insert( san );
		modify ( $member ){
			setActive(false)
		}
		logger.info(san);
end
		
rule "Sanction monitored nonmembers and change frequency of appropriation"
	ruleflow-group "report"
	no-loop //??
	when
		$pool : CommonPool($pid : id )
		Institution($round : round, pool == $pool, principle1 == true)//if no institution attached, no sancions
		Monitored( $name : agent, round == $round )
		not Sanctioned( agent == $name, round == $round )
		$nonmember : NonMember( name == $name, pool == $pid ) 
		Appropriated(agent == $name, round == $round, $approp : quantity, pool == $pool, $approp > 0)
	then 
		Sanctioned san =  new Sanctioned($name, $round, 1);
		insert( san );
		modify ( $nonmember ){
			setActive(false)
		}
		modify($pool){//appropriate less in future rounds
			setOutAppropriationFrequency( $pool.getOutAppropriationFrequency()
				 - ($pool.getOutAppropriationFrequency() *$pool.getOutImproveFrequency()) )
		}
		logger.info(san);
end

rule "Eliminate sancioned member from demandQueue"
	ruleflow-group "report"
	no-loop
	when
		$i : Institution($iid : id, $round : round, allocationMethod == RaMethod.QUEUE)
		Sanctioned($name : agent, round == $round)
		Member(name == $name, institutionId == $iid)
		$d : Demand( agent == $name, this memberOf $i.demandQueue ) //placed demand in previous timestep, still in queue.
	then
		modify($i){
			demandQueue.remove($d);
		}
end

rule "Members appeal against sanction"
	ruleflow-group "appeal"
	salience 1000
	when
		$i : Institution($iid : id, $round : round, principle6 == true)
		Sanctioned($name : agent, round == $round)
		$member: Member(name == $name, institutionId == $iid, active == false)
		not (Sanctioned(agent == $name, $rd : round, $round - $rd <= $i.appealtime) and
			Appealed(agent == $name, round >= $rd))
		not Appealed(agent == $name, round == $round)
	then
		Appealed appeal = new Appealed($name, $round);
		insert(appeal);
		modify ( $member ){
			setActive(true)
		}
		logger.info(appeal);
end

rule "Members appeal after recent sanction"
	ruleflow-group "appeal"
	salience 1000
	when
		$i : Institution($iid : id, $round : round, principle6 == true)
		Sanctioned($name : agent, round == $round)
		$member: Member( name == $name, institutionId == $iid, active == false)
		not (Sanctioned(agent == $name, $rd : round, $level : level, $round - ($rd + $level*$i.excludetime) <= $i.appealtime) and
			not Appealed(agent == $name, round >= $rd))
		not Appealed(agent == $name, round == $round)
	then
		Appealed appeal = new Appealed($name, $round);
		insert(appeal);
		modify ( $member ){
			setActive(true)
		}
		logger.info(appeal);
end

rule "member exclusion"//member inactive -> nonmember active
	ruleflow-group "exclude"
	when
		Institution($iid : id, $round : round, principle5 == false)
		$member : Member($name : name, institutionId == $iid, active == false)
		Sanctioned(agent == $name, round == $round)
	then
		retract($member);
		insert(new NonMember($member));
		logger.info("Excluded "+ $member);
end

rule "member exclusion with graduated sanctions"//member inactive -> nonmember active
	ruleflow-group "exclude"
	when
		$i : Institution($iid : id, $round : round, principle5 == true)
		$member: Member($name : name, institutionId == $iid, active == false)
		Sanctioned(agent == $name, round == $round, $level : level, level > $i.maxSanctionLevel)
	then
		retract($member);
		insert(new NonMember($member));
		logger.info("Excluded "+ $member);
end

rule "member back after sanction" //member inactive -> member active (Pr4/5)
	ruleflow-group "exclude"
	no-loop
	when
		$i : Institution($iid : id, $round : round, principle5 == true)
		$member: Member( $name : name, institutionId == $iid, active == false)
		$s : Sanctioned(agent == $name, $sanRd : round, $level : level, ($sanRd + $level*$i.excludetime < $round), 
			 $level <= $i.maxSanctionLevel)
		not Sanctioned(agent == $name, $rd : round, $rd > $sanRd)
	then
		if(Random.randomDouble() < 0.1){ //applyperc = 0.1; if agent wants to get back in this timestep, once allowed
			$member.changeBehaviour($i.getMaxSanctionLevel(), $s.getLevel());
			modify ( $member ){
				setActive(true)
			}
			logger.info("Back in: "+ $member);
		}
end

rule "assign new head" //so far, head also governs if inactive!!
	ruleflow-group "exclude"
	when
		Institution($iid : id, $round : round)
		not( exists( Head(institutionId == $iid)))
		$members : List( size > 0 ) from collect( Member( institutionId == $iid) )
	then
		Member m = (Member) $members.get(Random.randomInt($members.size()));
		retract(m);
		insert(new Head(m));
		logger.info("New Head "+ m);
end

rule "End of the institution"
	ruleflow-group 'init'
	when 
		$i : Institution($iid : id)
		not( exists( Member( institutionId == $iid) ))
	then
		retract($i);
		logger.info("ANARCHY!!");
end