package allocation

import allocation.*
import allocation.facts.*
import allocation.actions.*
import allocation.newagents.*
import uk.ac.imperial.presage2.core.IntegerTime
import uk.ac.imperial.presage2.core.util.random.Random
import java.util.HashMap
import java.util.List
import java.util.Set

global org.apache.log4j.Logger logger

declare TaskExecuted
	institution : Institution
	task : String
	round : int
end

declare Monitored
	agent : String
	round : int
end

declare Declared
	institution : int
	ballot : String
	round : int
	result : int
end

declare Deducted
	monitor : Monitored
end

declare Sanctioned
	agent : String //name
	round : int
	level : int
	institution : int
end

declare Appealed
	agent : String //name
	round : int
	institution : int
end
	

//sets IntegerTime and round number to be the same, first thing
rule "Increment round" 
	ruleflow-group 'init'
	salience 1000
	when
		$t : IntegerTime()
		$i : Institution( round < $t.intValue() )
	then
		modify($i) {
			incrementRound()
		}
end

rule "Count members" // not yet needed
	ruleflow-group 'init'
	when
		$i : Institution( $iid : id, $count : memberCount )
		List( size != $count, $members : size ) from collect( Member( institutionId == $iid ) )
	then
		modify($i) {
			setMemberCount( $members );
		}
end

rule "Count active members" // for member.demand()
	ruleflow-group 'init'
	when
		$i : Institution( $iid : id, $count : activeMemberCount )
		List( size != $count, $members : size ) from collect( Member( institutionId == $iid, active == true ) )
	then
		modify($i) {
			setActiveMemberCount( $members );
		}
end

rule "Disable votes" // head renews it every timestep in CFV
	ruleflow-group 'init'
	when 
		$inst : Institution( voteHead || voteRaMethod )
	then
		modify($inst) {
			setVoteHead( false ),
			setVoteRaMethod( false )
		}
end

rule "End of the institution"
	ruleflow-group 'init'
	when 
		$i : Institution( $iid : id )
		not( exists( Member( institutionId == $iid ) ))
	then
		retract($i);
		logger.info("ANARCHY!!");
end

rule "Call for votes"
	ruleflow-group 'cfv'
	no-loop
	when
		$i : Institution( $iid : id, principle3 == true)
		$head : Head( institutionId == $iid )
	then
		CallForVote cfv = $head.callForVotes( $i );
		if(cfv != null) {
			modify( $i ) {
				setVoteHead( cfv.isHead() ),	
				setVoteRaMethod( cfv.isRaMethod() )
			}
			logger.info(cfv);
		}
end


rule "Vote for RA method"
	salience 1000
	ruleflow-group 'vote'
	when
		$i : Institution( $iid : id, $pool : pool, voteRaMethod == true, $r : round , principle3 == true)
		$member : Member( institutionId == $iid, pool == $pool.id )
	then
		Vote v = $member.vote( $i, $pool, "raMethod" );
		if(v != null) {
			v.setVoter( $member.getName() );
			v.setRound( $r );
			insert(v);
			logger.info(v);
		}
end

rule "Count votes"
	ruleflow-group 'vote'
	when
		Institution( $iid : id , $round : round, principle3 == true )
		Member( $ag : name, institutionId == $iid )
		Vote( voter == $ag, round == $round, $b : ballot )
		not VoteCount( institution == $iid, ballot == $b, round == $round )
		$votes : List( size > 0 ) from accumulate( 
			$v : Vote( $voter : voter, round == $round, ballot == $b ) and 
			Member( name == $voter, institutionId == $iid ) , collectList($v) )
	then
		HashMap<Integer, Integer> tally = new HashMap<Integer, Integer>();
		for( Object o : $votes ) {
			Vote v = (Vote) o; // vote->(ballot,value)
			if(tally.containsKey(v.getValue())) {
				tally.put(v.getValue(), tally.get(v.getValue()) + 1);
			} else {
				tally.put(v.getValue(), 1);
			}
		}
		VoteCount vc = new VoteCount( $iid, $b, $round, tally );
		insert(vc);
		logger.info(vc);
end

rule "Declare winner and update Ra method" //if votes equal, nothing happens;
	ruleflow-group 'vote'
	when
		$i : Institution( $iid : id, $round : round , principle3 == true )
		$vc : VoteCount( ballot == "raMethod", round == $round, institution == $iid)
	then
		Integer forQueue = $vc.result.get(RaMethod.QUEUE.ordinal());
		Integer forRation = $vc.result.get(RaMethod.RATION.ordinal());
		if(forQueue == null) forQueue = 0;
		if(forRation == null) forRation = 0;

		if(forQueue > forRation) {
			$i.setAllocationMethod( RaMethod.QUEUE );
		} else if(forRation > forQueue) {
			$i.setAllocationMethod( RaMethod.RATION );
		}
		insert(new Declared( $iid, $vc.ballot, $vc.round, $i.getAllocationMethod().ordinal() ));
		logger.info("Allocation method for institution "+ $iid +" set to "+ $i.getAllocationMethod()); 
end

rule "External assignment of RaMethod"
	ruleflow-group 'vote'
	when
		$i : Institution( $iid : id, $pool : pool, $r : round, round % samplingrate == 0, principle3 == false)
		$hd : Head( institutionId == $iid )
	then
		if ($pool.getResourceLevel() < 1.5*$i.getInitialAgents()*$hd.getStandardRequest()){
			$i.setAllocationMethod( RaMethod.RATION );
		}
		else
			$i.setAllocationMethod( RaMethod.QUEUE );
		insert(new Declared( $iid, "raMethod", $r, $i.getAllocationMethod().ordinal() ));
		logger.info("Allocation method for institution "+ $iid +" externally set to "+ $i.getAllocationMethod());
end

rule "Reset demand-queue if necessary" //when switch from QUEUE to RATION
	ruleflow-group 'vote'
	when 
		$i : Institution( $iid : id , $r : round )
		Declared(institution == $iid, ballot == "raMethod",  result == RaMethod.RATION.ordinal(), round == $r )
		Declared(institution == $iid, ballot == "raMethod", result == RaMethod.QUEUE.ordinal(), $rb : round, $rb < $r)
		not Declared(institution == $iid, ballot == "raMethod", result == RaMethod.RATION.ordinal(), round > $rb)
	then
		$i.demandQueue.clear();
end
		

rule "Member Demands"
	salience 1000
	ruleflow-group 'demand'
	no-loop //no agent allowed to demand twice
	when
		$i : Institution( $iid : id, $pool : pool, $round : round, principle2 == true )
		$member : Member( institutionId == $iid )
		//no agent allowed to demand if on queue:
		not Demand( agent == $member.name, round < $round, this memberOf $i.demandQueue )
	then
		insert( new Demand( $member.getName(), $round, $member.demand( $i, $pool ), $pool.getId() ) );
end

rule "Agent monitoring list" 
	//independent of principles: collect all (non-)members
	//must be known before allocation, only monitor 'active', see head.monitor
	//head.monitor writes those on list (=monitored string) who should be monitored
	ruleflow-group "allocate" 
	salience 1000
	when
		$i : Institution( $iid : id, $pool : pool, $round : round )
		$head : Head( institutionId == $iid, pool == $pool.id )
		$members : Set( ) from collect( Member( institutionId == $iid) )
		$nonMembers : Set( ) from collect( NonMember( pool == $pool.id) )
		not TaskExecuted( $i, "monitor", $round ;)
	then
		Set<String> monitored = $head.monitor( $i, $pool, $members, $nonMembers );
		logger.info("Monitoring list: "+ monitored);
		for( String agent : monitored ) {
			insert( new Monitored( agent, $round ) );
		}
		insert( new TaskExecuted( $i, "monitor", $round ) );
end

rule "Perform resource allocation"
	ruleflow-group 'allocate'
	when
		$i : Institution( $iid : id, $pool : pool, $round : round, principle2 == true )
		$hd : Head( institutionId == $iid )
		$demands : List( ) from collect( Demand( pool == $pool.id, round == $round ) )
	then
		logger.info( $demands );
		Set<Allocation> allocations = $hd.allocate($i, $pool, $demands);
		logger.info(allocations);
		for(Allocation a : allocations) {
			insert(a);
		}
end
  
rule "Member appropriation - no allocation" //what principle active see member.appropriate()
	salience 1000
	ruleflow-group "appropriate"
	no-loop
	when
		$i : Institution( $iid : id, $pool : pool, $round : round )
		$member : Member( institutionId == $iid )
		not Appropriated( round == $round, agent == $member.getName() )
		not Allocation( round == $round, agent == $member.getName() )
	then
		double appropriatedAmount = $member.appropriate( $i, $pool, null );
		Appropriated app = new Appropriated( $member.getName(), $round, appropriatedAmount, $pool );
		insert( app );
		modify($pool) {
			setResourceLevel( $pool.getResourceLevel() - appropriatedAmount )
		}
		logger.info(app);
		logger.info($pool);
end

rule "Member appropriation - allocated"
	salience 1000
	ruleflow-group "appropriate"
	no-loop
	when
		$i : Institution( $iid : id, $pool : pool, $round : round )
		$member : Member( institutionId == $iid )
		not Appropriated( round == $round, agent == $member.getName() )
		$all : Allocation( round == $round, agent == $member.getName(), pool == $pool )
	then
		double appropriatedAmount = $member.appropriate( $i, $pool, $all );
		Appropriated app = new Appropriated( $member.getName(), $round, appropriatedAmount, $pool );
		insert( app );
		modify($pool) {
			setResourceLevel( $pool.getResourceLevel() - appropriatedAmount )
		}
		logger.info(app);
		//logger.info($pool);
end

// rule "Nonmember appropriation" in environment.drl

rule "Deduct member monitoring cost" // happens after appropriation
	ruleflow-group "appropriate"
	when
		$i : Institution( $iid : id, $pool : pool, $round : round )
		Member( $name : name, institutionId == $iid, pool == $pool.id)
		$m : Monitored( agent == $name, round == $round )
		not Deducted( $m ;)
	then
		modify( $pool ) {
			setResourceLevel( $pool.getResourceLevel() - $i.getMonitoringCost() ) 
		}
		Deducted ded = new Deducted( $m );
		insert(ded);
		//logger.info(ded);
end

rule "Deduct nonMember monitoring cost" // happens after appropriation
	ruleflow-group "appropriate"
	when
		$i : Institution( $round : round, $pool : pool )
		NonMember( $name : name, pool == $pool.id )
		$m : Monitored( agent == $name, round == $round )
		not Deducted( $m ;)
	then
		modify( $pool ) {
			setResourceLevel( $pool.getResourceLevel() - $i.getOutMonitoringCost() ) 
		}
		insert( new Deducted( $m ) );
end

rule "Sanctioning monitored members (first time or no graduated sanctions)" //not very important that it's the monitor/head
	ruleflow-group "report"
	no-loop 
	when
		Institution( $iid : id, $pool : pool, $round : round) //principle 4, graduation later.
		$member: Member( $name : name, institutionId == $iid, pool == $pool.id )
		Monitored( agent == $name, round == $round )
		not Sanctioned( agent == $name, round == $round )
		(	(Allocation(agent == $name, round == $round, $alloc : quantity, pool == $pool) and //agent had been allocated
			Appropriated(agent == $name, round == $round, $approp : quantity, pool == $pool, $approp > $alloc))
		or
			(not Allocation(agent == $name, round == $round, pool == $pool) and //agent had not been allocated
			Appropriated(agent == $name, round == $round, $approp : quantity, pool == $pool, $approp > 0))	)
		not Sanctioned(agent == $name)
	then 
		Sanctioned san = new Sanctioned($name, $round, 1, $iid);
		insert( san );
		modify ( $member ){
			setActive(false)
		}
		logger.info(san);
end

rule "Sanctioning monitored members (repeatedly)"
	ruleflow-group "report"
	no-loop 
	when
		Institution( $iid : id, $pool : pool, $round : round, principle5 == true)
		$member: Member( $name : name, institutionId == $iid, pool == $pool.id )
		Monitored( agent == $name, round == $round )
		not Sanctioned( agent == $name, round == $round )
		(	(Allocation(agent == $name, round == $round, $alloc : quantity, pool == $pool) and //agent had been allocated
			Appropriated(agent == $name, round == $round, $approp : quantity, pool == $pool, $approp > $alloc))
		or
			(not Allocation(agent == $name, round == $round, pool == $pool) and //agent had not been allocated
			Appropriated(agent == $name, round == $round, $approp : quantity, pool == $pool, $approp > 0))	)
		Sanctioned(agent == $name, $level : level) //highest level of sanctioning
		not Sanctioned(agent == $name, $l : level, $l > $level)
		
	then 
		Sanctioned san = new Sanctioned($name, $round, $level+1, $iid);
		insert( san );
		modify ( $member ){
			setActive(false)
		}
		logger.info(san);
end
		
rule "Sanction monitored nonmembers and change frequency of appropriation"
	ruleflow-group "report"
	no-loop
	when
		Institution( $iid : id, $pool : pool, $round : round, principle1 == true)//if no institution attached, no sancions
		$nonmember : NonMember( $name : name, pool == $pool.id ) 
		Monitored( agent == $name, round == $round )
		not Sanctioned( agent == $name, round == $round, institution == $iid )
		Appropriated(agent == $name, round == $round, $approp : quantity, pool == $pool, $approp > 0)
	then 
		Sanctioned san =  new Sanctioned($name, $round, 1, $iid);
		insert( san );
		modify ( $nonmember ){
			setActive(false)
		}
		modify($pool){//appropriate less in future rounds
			setOutAppropriationFrequency( $pool.getOutAppropriationFrequency()
				 - ($pool.getOutAppropriationFrequency() *$pool.getOutImproveFrequency()) )
		}
		logger.info(san);
end

rule "Eliminate sanctioned member from demandQueue"
	ruleflow-group "report"
	no-loop
	when
		$i : Institution($iid : id, $round : round, allocationMethod == RaMethod.QUEUE)
		Member($name : name, institutionId == $iid)
		Sanctioned( agent == $name, round == $round)
		$d : Demand( agent == $name, this memberOf $i.demandQueue ) //placed demand in previous timestep, still in queue.
	then
		modify($i){
			demandQueue.remove($d);
		}
end


rule "Members appeal against sanction"
	ruleflow-group "appeal"
	when
		$i : Institution($iid : id, $round : round, principle6 == true)
		$member: Member($name : name, institutionId == $iid, active == false)
		$san : Sanctioned(agent == $name, round == $round)
		not (Appealed(agent == $name, $aRd : round, $round - $aRd <= $i.appealtime, institution == $iid))
		not (Sanctioned(agent == $name, $sRd : round, $level : level, $sRd < $round, $round - ($sRd + $level*$i.excludetime) <= $i.appealtime, institution == $iid))
	then
		Appealed appeal = new Appealed($name, $round, $iid);
		insert(appeal);
		retract($san);
		modify ( $member ){
			setActive(true)
		}
		logger.info(appeal);
end

/*rule "Members appeal against sanction"
	ruleflow-group "appeal"
	when
		$i : Institution($iid : id, $round : round, principle6 == true)
		$member: Member($name : name, institutionId == $iid, active == false)
		Sanctioned(agent == $name, round == $round)
		not (Sanctioned(agent == $name, $rd : round, $round - $rd <= $i.appealtime) and
			Appealed(agent == $name, round >= $rd, institution == $iid))
		not Appealed(agent == $name, round == $round, institution == $iid)
	then
		Appealed appeal = new Appealed($name, $round, $iid);
		insert(appeal);
		modify ( $member ){
			setActive(true)
		}
		logger.info(appeal);
end

rule "Members appeal after recent sanction"
	ruleflow-group "appeal"
	when
		$i : Institution($iid : id, $round : round, principle6 == true)
		$member: Member( $name : name, institutionId == $iid, active == false)
		Sanctioned(agent == $name, round == $round)
		not (Sanctioned(agent == $name, $rd : round, $level : level, $round - ($rd + $level*$i.excludetime) <= $i.appealtime) and
			not Appealed(agent == $name, round >= $rd, institution == $iid))
		not Appealed(agent == $name, round == $round, institution == $iid)
	then
		Appealed appeal = new Appealed($name, $round, $iid);
		insert(appeal);
		modify ( $member ){
			setActive(true)
		}
		logger.info(appeal);
end*/

rule "member exclusion"//member inactive -> nonmember active
	ruleflow-group "exclude"
	when
		Institution($iid : id, $round : round, principle5 == false)
		$member : Member($name : name, institutionId == $iid, active == false)
		Sanctioned(agent == $name, round == $round)
	then
		retract($member);
		insert(new NonMember($member));
		logger.info("Excluded "+ $member);
end

rule "member exclusion with graduated sanctions"//member inactive -> nonmember active
	ruleflow-group "exclude"
	when
		$i : Institution($iid : id, $round : round, principle5 == true)
		$member: Member($name : name, institutionId == $iid, active == false)
		Sanctioned(agent == $name, round == $round, $level : level, level > $i.maxSanctionLevel)
	then
		retract($member);
		insert(new NonMember($member));
		logger.info("Excluded "+ $member);
end

rule "member back after sanction" //member inactive -> member active (Pr4/5)
	ruleflow-group "exclude"
	no-loop
	when
		$i : Institution($iid : id, $round : round, principle5 == true)
		$member: Member( $name : name, institutionId == $iid, active == false)
		$s : Sanctioned(agent == $name, $sanRd : round, $level : level, ($sanRd + $level*$i.excludetime < $round), 
			 $level <= $i.maxSanctionLevel)
		not Sanctioned(agent == $name, $rd : round, $rd > $sanRd)
	then
		if(Random.randomDouble() < 0.1){ //applyperc = 0.1; if agent wants to get back in this timestep, once allowed
			$member.changeBehaviour($i.getMaxSanctionLevel(), $s.getLevel());
			modify ( $member ){
				setActive(true)
			}
			logger.info("Back in: "+ $member);
		}
end

rule "assign new head" //so far, head also governs if inactive!!
	ruleflow-group "exclude"
	when
		Institution($iid : id, $round : round)
		not( exists( Head(institutionId == $iid)))
		$members : List( size > 0 ) from collect( Member( institutionId == $iid) )
	then
		Member m = (Member) $members.get(Random.randomInt($members.size()));
		retract(m); //drools will treat head as member
		insert(new Head(m));
		logger.info("New Head "+ m);
end
