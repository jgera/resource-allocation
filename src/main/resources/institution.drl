package allocation

import allocation.*
import allocation.facts.*
import allocation.actions.*
import allocation.agents.*
import uk.ac.imperial.presage2.core.IntegerTime
import java.util.HashMap
import java.util.List
import java.util.Set

global org.apache.log4j.Logger logger

rule "Mark VoteCalled when valid cfv"
	when
		$cfv : CallForVote( $ag : player, player.role == Role.HEAD, $round : round )
		Agent( this == $ag, $iid : institutionId )
		not( exists( Processed( $cfv ;) ) )
		$inst : Institution( id == $iid, round == $round )
	then
		modify($inst) {
			setVoteHead( $cfv.isHead() ),
			setVoteRaMethod( $cfv.isRaMethod() )
		}
		insert( new Processed( $cfv ) );
		logger.info($cfv);
end

rule "Disable votes"
	when 
		$inst : Institution( $iid : id, $round : round, ( voteHead == true || voteRaMethod == true ) )
		not( CallForVote( player.institutionId == $iid, round == $round ) )
	then
		modify($inst) {
			setVoteHead( false ),
			setVoteRaMethod( false )
		}
end

rule "Declare vote winner"
	when
		Institution( $iid : id, $round : round )
		Vote( player.institutionId == $iid, round == $round, $b : ballot )
		not Declared( institution == $iid, ballot == $b, round == $round )
		$votes : List( size > 0 ) from collect( Vote( player.institutionId == $iid, round == $round, ballot == $b ) )
	then
		HashMap<Integer, Integer> tally = new HashMap<Integer, Integer>();
		for( Object o : $votes ) {
			Vote v = (Vote) o;
			if(tally.containsKey(v.getValue())) {
				tally.put(v.getValue(), tally.get(v.getValue()) + 1);
			} else {
				tally.put(v.getValue(), 1);
			}
		}
		insert( new Declared( $iid, $b, $round, tally ) );
end

rule "Echo declared"
	when
		$d : Declared()
	then
		logger.info( $d );
end

rule "Update Ra method"
	when
		$d : Declared( ballot == "raMethod", $iid : institution )
		$i : Institution( id == $iid, round == $d.round )
	then
		Integer forQueue = $d.result.get(RaMethod.QUEUE.ordinal());
		Integer forRation = $d.result.get(RaMethod.RATION.ordinal());
		if(forQueue == null) forQueue = 0;
		if(forRation == null) forRation = 0;

		if(forQueue > forRation) {
			$i.setAllocationMethod( RaMethod.QUEUE );
		} else if(forRation > forQueue) {
			$i.setAllocationMethod( RaMethod.RATION );
		}
		logger.info("Allocation method for institution "+ $iid +" set to "+ $i.getAllocationMethod()); 
end

rule "Do allocation"
	when
		// get an institution in allocate phase
		$inst : Institution( $iid : id, $round : round, $pools : pools, state == Phase.Allocate )
		// get a pool from this institution
		$pool : CommonPool( this memberOf $pools )
		// get the head
		$ag : Agent( role == Role.HEAD, institutionId == $iid )
		// get demands for this pool
		$demands : List( size > 0 ) from collect( Demand( pool == $pool.id ) )
	then
		logger.info( $ag );
		logger.info( $demands );
		Set<Allocation> allocations = $ag.doAllocation($pool, $demands);
		logger.info(allocations);
		for(Allocation a : allocations) {
			insert(a);
		}
end

rule "Notify agents of allocations"
	when
		Institution( $iid : id, $round : round )
		$all : Allocation( $ag : player, round == $round )
		not Processed( $all ;)
		Agent( this == $ag, institutionId == $iid )
	then
		$ag.setAllocation($all);
		insert( new Processed($all) );
end

rule "Reset allocations"
	when
		Institution( $iid : id, $round : round, state == Phase.CFV )
		$ag : Agent( )
	then
		$ag.setAllocation(null);
end

rule "Deduct member monitoring cost" //julia: happens after appropriation!! 
	when
		$i : Institution( $iid : id, $round : round, state == Phase.Appropriate )
		Monitor( $ag : monitored, round == $round )
		Agent( this == $ag, institutionId == $iid )
		$pool : CommonPool( id == $ag.getPool() )
	then
		modify( $pool ) {
			setResourceLevel( $pool.getResourceLevel() - $i.getMonitoringCost() ) 
		}
end

rule "Monitor member agents" //julia: check conditions
	when
		$i : Institution( $iid : id, $round : round, state == Phase.Appropriate )
		Monitor( $ag : monitored, round == $round )
		Agent( this == $ag, institutionId == $iid)
		$pool : CommonPool( id == $ag.getPool() )
		Allocation( player == $ag, round == $round, $quantity : quantity )
		Appropriate(player == $ag, round == $round, pool == $pool, amount > $quantity )
    then
    	if($i.isPrinciple5()){
    		//do graduated sanctions
    	}
    	else{
    		$ag.setRole(Role.NONMEMBER);
    	}
end

rule "Deduct nonmember monitoring cost" //julia: happens after appropriation!! 
	when
		$i : Institution( $iid : id, $round : round, state == Phase.Appropriate )
		OutMonitor( $ag : outMonitored, round == $round )
		Agent( this == $ag)
		$pool : CommonPool( id == $ag.getPool() )
	then
		modify( $pool ) {
			setResourceLevel( $pool.getResourceLevel() - $i.getOutMonitoringCost() ) 
		}
end

rule "Sanction nonmembers and change appropriating frequency" //julia: check conditions
	when
		$i : Institution( $iid : id, $round : round, state == Phase.Appropriate )
		OutMonitor( $ag : outMonitored, round == $round )
		Agent( this == $ag, institutionId == $iid)
		$pool : CommonPool( id == $ag.getPool() )
		//Allocation( player == $ag, round == $round, $quantity : quantity)
		Appropriate(player == $ag, round == $round, pool == $pool, amount > 0)
    then
    	// $ag.active = false;
    	/*modify($i){//non-member-wide variables (or these variables could be tied to an institution => describes how hard/easy it is to appropriate there)
			setOutAppropriationFrequency($i.getOutAppropriationFrequency() *$i.outImproveFrequency)//appropriate less in future rounds
		}*/
end

